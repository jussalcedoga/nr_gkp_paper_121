#!/usr/bin/env python3
# -*- coding: utf-8 -*-
r"""
gkp_overlap_qcomb_scan.py  (parallel, with squeezing in dB)

Characterize the logical overlap
    O(N, r, Δ) = |<0_L|1_L>|^2

for q-comb GKP states generated by:
    logical_eigenstates_qcomb(N, M, r, Delta)

We scan:
    • Fock cutoff N
    • squeezing parameter r (and report it as squeezing_dB)
    • comb parameter Δ

Data is saved to:
    data_gkp_overlap_qcomb/gkp_overlap_qcomb_scan.npz

The file contains:
    M              (scalar)
    N_list         (nN,)        integers
    r_list         (nR,)        raw squeezing r
    r_dB_list      (nR,)        squeezing in dB
    Delta_list     (nD,)
    overlap        (nR, nN, nD)  |<0_L|1_L>|^2

Quick-look figures are saved to:
    figs_gkp_overlap_qcomb/overlap_N_Delta_rXXdB.png
"""

import os
import numpy as np
import matplotlib as mpl
import matplotlib.pyplot as plt
from matplotlib.ticker import FormatStrFormatter
from concurrent.futures import ProcessPoolExecutor
from tqdm.auto import tqdm

from gkp_qcomb_stateprep_panels import logical_eigenstates_qcomb

# ---------- Matplotlib style ----------
plt.rcParams.update({
    "font.size": 16,
    "font.family": "sans-serif",
    "font.sans-serif": ["Helvetica"],
    "text.usetex": False,
})
mpl.rcParams["axes.unicode_minus"] = False


def ket_fidelity(psi, phi) -> float:
    """Return |<psi|phi>|^2."""
    ov = psi.overlap(phi)
    return float(abs(ov)**2)


def integer_linspace(Nmin: int, Nmax: int, n_points: int):
    """Evenly spaced integers between Nmin and Nmax (inclusive-ish)."""
    arr = np.linspace(Nmin, Nmax, n_points)
    return sorted(set(int(round(v)) for v in arr))


def r_to_dB(r: float) -> float:
    """
    Convert squeezing parameter r to dB, assuming:
        Var_q = e^{-2r} * Var_vac
    and 'squeezing in dB' = 10 log10(Var_vac / Var_q) = 20 r / ln(10).
    """
    return 20.0 * r / np.log(10.0)


def worker_task(args):
    """Parallel worker: compute overlap for (N, M, r, Delta)."""
    N, M, r, Delta = args
    try:
        psi0, psi1, *_ = logical_eigenstates_qcomb(N, M, r, Delta)
        ov = ket_fidelity(psi0, psi1)
    except Exception as exc:
        print(f"[Error] N={N}, r={r:.3f}, Δ={Delta:.3f}: {exc}")
        ov = np.nan
    return N, r, Delta, ov


def main():
    # ---------------- Configuration ----------------
    M = 5

    # Fock cutoffs
    N_list = integer_linspace(30, 80, 7)

    # Squeezing r (dimensionless), but we report it in dB
    r_list = np.linspace(0.6, 1.2, 4)
    r_dB_list = np.array([r_to_dB(r) for r in r_list])

    # Comb parameter Δ (whatever convention gkp_qcomb_stateprep_panels uses)
    Delta_list = np.linspace(0.18, 0.32, 9)

    data_dir = "data_gkp_overlap_qcomb"
    fig_dir = "figs_gkp_overlap_qcomb"
    os.makedirs(data_dir, exist_ok=True)
    os.makedirs(fig_dir, exist_ok=True)

    print("=== Parallel GKP q-comb overlap scan ===")
    print(f"N_list      = {N_list}")
    print("r_list      = [" + ", ".join(f"{r:.3f}" for r in r_list) + "]")
    print("r_dB_list   = [" + ", ".join(f"{rdB:.2f} dB" for rdB in r_dB_list) + "]")
    print("Delta_list  = [" + ", ".join(f"{d:.3f}" for d in Delta_list) + "]")
    print()

    # ---------------- Build task list ----------------
    tasks = [(N, M, r, D) for r in r_list for N in N_list for D in Delta_list]
    total = len(tasks)

    # ---------------- Parallel execution --------------
    results = []
    with ProcessPoolExecutor() as pool:
        for item in tqdm(pool.map(worker_task, tasks), total=total,
                         desc="Overlap grid (N, r, Δ)"):
            results.append(item)

    # ---------------- Pack into array -----------------
    nR, nN, nD = len(r_list), len(N_list), len(Delta_list)
    overlap = np.zeros((nR, nN, nD), dtype=float)

    # For indexing convenience
    r_to_idx = {float(r): i for i, r in enumerate(r_list)}
    N_to_idx = {int(N): i for i, N in enumerate(N_list)}
    D_to_idx = {float(D): i for i, D in enumerate(Delta_list)}

    for N, r, D, ov in results:
        i_r = r_to_idx[float(r)]
        i_N = N_to_idx[int(N)]
        i_D = D_to_idx[float(D)]
        overlap[i_r, i_N, i_D] = ov

    # ---------------- Save data -----------------------
    out_npz = os.path.join(data_dir, "gkp_overlap_qcomb_scan.npz")
    np.savez(
        out_npz,
        M=int(M),
        N_list=np.array(N_list, dtype=int),
        r_list=np.array(r_list, dtype=float),
        r_dB_list=np.array(r_dB_list, dtype=float),
        Delta_list=np.array(Delta_list, dtype=float),
        overlap=overlap,
    )
    print(f"\nSaved overlap scan data to: {out_npz}\n")

    # ---------------- Quick-look plots ----------------
    finite = overlap[np.isfinite(overlap)]
    if finite.size > 0:
        vmin = 0.0
        vmax = float(np.nanmax(finite))
        vmax = max(vmax, 1e-6)
        vmax = min(vmax, 1.0)
    else:
        vmin, vmax = 0.0, 1.0

    N_arr = np.array(N_list, dtype=float)
    D_arr = np.array(Delta_list, dtype=float)

    for i_r, (r, r_dB) in enumerate(zip(r_list, r_dB_list)):
        data_slice = overlap[i_r]  # shape: (nN, nD)

        fig, ax = plt.subplots(figsize=(8, 6))
        im = ax.imshow(
            data_slice,
            origin="lower",
            aspect="auto",
            extent=[D_arr[0], D_arr[-1], N_arr[0], N_arr[-1]],
            cmap="bwr",
            vmin=vmin,
            vmax=vmax,
        )

        ax.set_xlabel(r"$\Delta$")
        ax.set_ylabel(r"$N$")
        ax.set_title(
            r"$|\langle 0_L|1_L\rangle|^2$"
            + fr"  (squeezing ≈ {r_dB:.1f} dB)"
        )

        cbar = fig.colorbar(im, ax=ax, fraction=0.046, pad=0.04)
        cbar.set_label(r"$|\langle 0_L|1_L\rangle|^2$")
        cbar.ax.yaxis.set_major_formatter(FormatStrFormatter("%.2f"))

        fig.tight_layout()
        outfig = os.path.join(
            fig_dir,
            f"overlap_N_Delta_squeezing_{r_dB:+04.1f}dB.png",
        )
        fig.savefig(outfig, dpi=230)
        plt.close(fig)
        print(f"Saved {outfig}")

    print("\nAll figures saved in ./figs_gkp_overlap_qcomb/")
    print("You can now re-plot from the .npz without recomputing.\n")


if __name__ == "__main__":
    main()
